/**
 * @file LFTri.h
 * @brief Non-band-limited triangle oscillator UGen.
 *
 * LFTri generates a triangle wave using a phase accumulator.
 * Output ranges from -1 to +1.
 * Designed for embedded use with no heap allocation and no virtual calls.
 */

#ifndef SUBCOLLIDER_UGENS_LFTRI_H
#define SUBCOLLIDER_UGENS_LFTRI_H

#include "../types.h"
#include <cmath>

namespace subcollider {
namespace ugens {

/**
 * @brief Non-band-limited triangle oscillator using phase accumulator.
 *
 * This is a static struct with inline per-sample processing,
 * suitable for embedded DSP with no heap allocation.
 *
 * The triangle wave is generated by folding a sawtooth wave:
 * - Phase goes from 0 to 1
 * - Output is computed as: 4 * |phase - 0.5| - 1
 * - This gives a triangle ranging from -1 to +1
 *
 * Usage:
 * @code
 * LFTri tri;
 * tri.init(48000.0f);
 * tri.setFrequency(440.0f);
 *
 * // Per-sample processing
 * float sample = tri.tick();
 *
 * // Block processing
 * float buffer[64];
 * tri.process(buffer, 64);
 * @endcode
 */
struct LFTri {
    /// Current phase [0, 1]
    Sample phase;

    /// Phase increment per sample
    Sample phaseIncrement;

    /// Frequency in Hz
    Sample frequency;

    /// Sample rate in Hz
    Sample sampleRate;

    /**
     * @brief Initialize the oscillator.
     * @param sr Sample rate in Hz (default: 48000)
     * @param iphase Initial phase offset [0, 4] (default: 0)
     *               Phase 0 and 2 start at 0 crossing going up/down
     *               Phase 1 starts at +1 (peak)
     *               Phase 3 starts at -1 (trough)
     */
    void init(Sample sr = DEFAULT_SAMPLE_RATE, Sample iphase = 0.0f) noexcept {
        sampleRate = sr;
        frequency = 440.0f;

        // Convert initial phase from [0, 4] to [0, 1]
        // iphase 0 = phase 0.25 (output 0, going up)
        // iphase 1 = phase 0.5 (output +1, peak)
        // iphase 2 = phase 0.75 (output 0, going down)
        // iphase 3 = phase 0.0 (output -1, trough)
        phase = iphase * 0.25f;

        // Wrap phase to [0, 1]
        phase = phase - std::floor(phase);

        updatePhaseIncrement();
    }

    /**
     * @brief Set oscillator frequency.
     * @param freq Frequency in Hz
     */
    void setFrequency(Sample freq) noexcept {
        frequency = freq;
        updatePhaseIncrement();
    }

    /**
     * @brief Update phase increment from current frequency.
     *
     * Call this at control rate when frequency changes.
     */
    void updatePhaseIncrement() noexcept {
        phaseIncrement = frequency / sampleRate;
    }

    /**
     * @brief Generate single sample (inline per-sample processing).
     * @return Next sample value [-1, 1]
     */
    inline Sample tick() noexcept {
        // Triangle wave: fold a ramp using absolute value
        // Output = 4 * |phase - 0.5| - 1
        // When phase = 0: output = 4 * 0.5 - 1 = 1
        // When phase = 0.25: output = 4 * 0.25 - 1 = 0
        // When phase = 0.5: output = 4 * 0 - 1 = -1
        // When phase = 0.75: output = 4 * 0.25 - 1 = 0
        // Wait, that gives peak at phase 0. Let me recalculate...
        
        // For standard triangle starting at -1 (trough) when phase = 0:
        // Output = 1 - 4 * |phase - 0.25|  for phase in [0, 0.5]
        // Actually, simpler: use piecewise linear
        // phase [0, 0.5]: output = 4 * phase - 1   (goes from -1 to +1)
        // phase [0.5, 1]: output = 3 - 4 * phase   (goes from +1 to -1)
        
        Sample out;
        if (phase < 0.5f) {
            out = 4.0f * phase - 1.0f;
        } else {
            out = 3.0f - 4.0f * phase;
        }

        // Advance phase
        phase += phaseIncrement;
        if (phase >= 1.0f) {
            phase -= 1.0f;
        }

        return out;
    }

    /**
     * @brief Process a block of samples.
     * @param output Output buffer
     * @param numSamples Number of samples to generate
     */
    void process(Sample* output, size_t numSamples) noexcept {
        for (size_t i = 0; i < numSamples; ++i) {
            output[i] = tick();
        }
    }

    /**
     * @brief Process a block, adding to existing buffer.
     * @param output Output buffer to add to
     * @param numSamples Number of samples to generate
     */
    void processAdd(Sample* output, size_t numSamples) noexcept {
        for (size_t i = 0; i < numSamples; ++i) {
            output[i] += tick();
        }
    }

    /**
     * @brief Reset oscillator to initial state.
     * @param newPhase Phase value [0, 1] (default: 0)
     */
    void reset(Sample newPhase = 0.0f) noexcept {
        phase = newPhase;
    }
};

} // namespace ugens
} // namespace subcollider

#endif // SUBCOLLIDER_UGENS_LFTRI_H
